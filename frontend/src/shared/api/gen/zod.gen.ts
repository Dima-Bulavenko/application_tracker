// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

export const zAccessTokenResponse = z.object({
  access_token: z.string(),
  token_type: z.optional(z.string()).default('bearer'),
});

export const zAppStatus = z.enum(['applied', 'interview', 'offer', 'rejected']);

export const zCompanyCreate = z.object({
  name: z.string().max(40),
});

export const zWorkType = z.enum([
  'full_time',
  'part_time',
  'internship',
  'contract',
  'other',
]);

export const zWorkLocation = z.enum(['on_site', 'remote', 'hybrid']);

export const zApplicationCreate = z.object({
  role: z.string(),
  company: zCompanyCreate,
  status: z.optional(zAppStatus),
  work_type: z.optional(zWorkType),
  work_location: z.optional(zWorkLocation),
  note: z.optional(z.union([z.string(), z.null()])),
  application_url: z.optional(z.union([z.string(), z.null()])),
  interview_date: z.optional(
    z.union([
      z.iso.datetime({
        offset: true,
      }),
      z.null(),
    ])
  ),
});

export const zApplicationOrderBy = z.enum(['time_create', 'time_update']);

export const zApplicationRead = z.object({
  role: z.string(),
  company_id: z.int(),
  user_id: z.int(),
  id: z.int(),
  status: zAppStatus,
  work_type: zWorkType,
  work_location: zWorkLocation,
  note: z.optional(z.union([z.string(), z.null()])),
  application_url: z.optional(z.union([z.string(), z.null()])),
  time_create: z.iso.datetime({
    offset: true,
  }),
  time_update: z.iso.datetime({
    offset: true,
  }),
  interview_date: z.optional(
    z.union([
      z.iso.datetime({
        offset: true,
      }),
      z.null(),
    ])
  ),
});

export const zCompanyRead = z.object({
  id: z.int().gt(0),
  name: z.string().max(40),
});

export const zApplicationReadWithCompany = z.object({
  role: z.string(),
  company_id: z.int(),
  user_id: z.int(),
  id: z.int(),
  status: zAppStatus,
  work_type: zWorkType,
  work_location: zWorkLocation,
  note: z.optional(z.union([z.string(), z.null()])),
  application_url: z.optional(z.union([z.string(), z.null()])),
  time_create: z.iso.datetime({
    offset: true,
  }),
  time_update: z.iso.datetime({
    offset: true,
  }),
  interview_date: z.optional(
    z.union([
      z.iso.datetime({
        offset: true,
      }),
      z.null(),
    ])
  ),
  company: zCompanyRead,
});

export const zApplicationUpdate = z.object({
  role: z.optional(z.union([z.string(), z.null()])),
  company: z.optional(z.union([zCompanyCreate, z.null()])),
  status: z.optional(z.union([zAppStatus, z.null()])),
  work_type: z.optional(z.union([zWorkType, z.null()])),
  work_location: z.optional(z.union([zWorkLocation, z.null()])),
  note: z.optional(z.union([z.string(), z.null()])),
  application_url: z.optional(z.union([z.string(), z.null()])),
  interview_date: z.optional(
    z.union([
      z.iso.datetime({
        offset: true,
      }),
      z.null(),
    ])
  ),
});

export const zCompanyOrderBy = z.enum(['name']);

export const zErrorResponse = z.object({
  detail: z.string(),
});

export const zValidationError = z.object({
  loc: z.array(z.union([z.string(), z.int()])),
  msg: z.string(),
  type: z.string(),
});

export const zHttpValidationError = z.object({
  detail: z.optional(z.array(zValidationError)),
});

export const zMessageResponse = z.object({
  message: z.string(),
});

export const zOAuthAuthorizeResponse = z
  .object({
    authorization_url: z.string().register(z.globalRegistry, {
      description: 'URL to redirect user to for OAuth authorization',
    }),
    state: z.string().register(z.globalRegistry, {
      description: 'CSRF protection state token',
    }),
  })
  .register(z.globalRegistry, {
    description: 'OAuth authorization URL response',
  });

export const zOAuthLoginResponse = z
  .object({
    access_token: z.string().register(z.globalRegistry, {
      description: 'JWT access token',
    }),
    token_type: z
      .optional(
        z.literal('bearer').register(z.globalRegistry, {
          description: 'Token type',
        })
      )
      .default('bearer'),
    is_new_user: z.boolean().register(z.globalRegistry, {
      description: 'Whether this is a new user registration',
    }),
  })
  .register(z.globalRegistry, {
    description: 'OAuth login/signup response with JWT tokens',
  });

export const zUserChangePassword = z.object({
  old_password: z
    .string()
    .regex(/^(?=.*[A-Z])(?=.*\d).{8,}$/)
    .register(z.globalRegistry, {
      description:
        'Password must be 8 characters long, contain at least one uppercase letter and one number.',
    }),
  new_password: z
    .string()
    .regex(/^(?=.*[A-Z])(?=.*\d).{8,}$/)
    .register(z.globalRegistry, {
      description:
        'Password must be 8 characters long, contain at least one uppercase letter and one number.',
    }),
  confirm_new_password: z
    .string()
    .regex(/^(?=.*[A-Z])(?=.*\d).{8,}$/)
    .register(z.globalRegistry, {
      description:
        'Password must be 8 characters long, contain at least one uppercase letter and one number.',
    }),
});

export const zUserCreate = z.object({
  username: z.email().register(z.globalRegistry, {
    description: "User's email address",
  }),
  password: z
    .string()
    .regex(/^(?=.*[A-Z])(?=.*\d).{8,}$/)
    .register(z.globalRegistry, {
      description:
        'Password must be 8 characters long, contain at least one uppercase letter and one number.',
    }),
});

export const zUserLogin = z.object({
  username: z.email().register(z.globalRegistry, {
    description: "User's email address",
  }),
  password: z
    .string()
    .regex(/^(?=.*[A-Z])(?=.*\d).{8,}$/)
    .register(z.globalRegistry, {
      description:
        'Password must be 8 characters long, contain at least one uppercase letter and one number.',
    }),
});

export const zUserRead = z.object({
  id: z.int(),
  username: z.email().register(z.globalRegistry, {
    description: "User's email address",
  }),
  first_name: z.optional(z.union([z.string().max(40), z.null()])),
  second_name: z.optional(z.union([z.string().max(40), z.null()])),
  time_create: z.iso.datetime({
    offset: true,
  }),
  time_update: z.iso.datetime({
    offset: true,
  }),
  is_active: z.optional(z.boolean()).default(true),
});

export const zUserSetPassword = z
  .object({
    new_password: z
      .string()
      .regex(/^(?=.*[A-Z])(?=.*\d).{8,}$/)
      .register(z.globalRegistry, {
        description:
          'Password must be 8 characters long, contain at least one uppercase letter and one number.',
      }),
    confirm_new_password: z
      .string()
      .regex(/^(?=.*[A-Z])(?=.*\d).{8,}$/)
      .register(z.globalRegistry, {
        description:
          'Password must be 8 characters long, contain at least one uppercase letter and one number.',
      }),
  })
  .register(z.globalRegistry, {
    description:
      'For OAuth users who want to set a password for the first time',
  });

export const zUserUpdate = z.object({
  first_name: z.optional(z.union([z.string().max(40), z.null()])),
  second_name: z.optional(z.union([z.string().max(40), z.null()])),
});

export const zCreateUserData = z.object({
  body: zUserCreate,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zActivateUserData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    token: z.string(),
  }),
});

export const zChangePasswordData = z.object({
  body: zUserChangePassword,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zSetPasswordData = z.object({
  body: zUserSetPassword,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zDeleteUserData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zGetCurrentUserData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zUpdateUserData = z.object({
  body: zUserUpdate,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zGetApplicationsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      limit: z
        .optional(
          z.int().gte(1).lte(50).register(z.globalRegistry, {
            description: 'Number of items to return',
          })
        )
        .default(10),
      offset: z
        .optional(
          z.int().gte(0).register(z.globalRegistry, {
            description:
              'Number of items to skip before starting to collect the result set',
          })
        )
        .default(0),
      order_by: z.optional(zApplicationOrderBy),
      order_direction: z.optional(z.enum(['asc', 'desc'])),
      status: z.optional(z.union([z.array(zAppStatus), z.null()])),
      work_type: z.optional(z.union([z.array(zWorkType), z.null()])),
      work_location: z.optional(z.union([z.array(zWorkLocation), z.null()])),
      role_name: z.optional(z.union([z.string(), z.null()])),
      company_name: z.optional(z.union([z.string(), z.null()])),
    })
  ),
});

export const zCreateApplicationData = z.object({
  body: zApplicationCreate,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zDeleteApplicationData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    application_id: z.int(),
  }),
  query: z.optional(z.never()),
});

export const zGetApplicationByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    application_id: z.int(),
  }),
  query: z.optional(z.never()),
});

export const zUpdateApplicationData = z.object({
  body: zApplicationUpdate,
  path: z.object({
    application_id: z.int(),
  }),
  query: z.optional(z.never()),
});

export const zGetUserCompaniesData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      limit: z
        .optional(
          z.int().gte(1).lte(50).register(z.globalRegistry, {
            description: 'Number of items to return',
          })
        )
        .default(10),
      offset: z
        .optional(
          z.int().gte(0).register(z.globalRegistry, {
            description:
              'Number of items to skip before starting to collect the result set',
          })
        )
        .default(0),
      order_by: z.optional(zCompanyOrderBy),
      order_direction: z.optional(z.enum(['asc', 'desc'])),
      name_contains: z.optional(z.union([z.string(), z.null()])),
    })
  ),
});

export const zGetCompanyData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    company_id: z.int(),
  }),
  query: z.optional(z.never()),
});

export const zLoginData = z.object({
  body: zUserLogin,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zRefreshTokenData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zLogoutData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zGoogleAuthorizeData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zGoogleCallbackData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    code: z.string(),
    state: z.string(),
  }),
});

export const zLinkedinAuthorizeData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zLinkedinCallbackData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    code: z.string(),
    state: z.string(),
  }),
});
